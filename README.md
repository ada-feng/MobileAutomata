# MobileAutomata
Mobile Automata uses Turing Machine to read and print patterns on a 2-d grid, so our project explored what patterns can there be and what such a machine can simulate. 
	First, we tried to build a square starting from the mid-point of a graph that grows and potentially fills the full space. At first, we try to do it the naïve way, just building a bunch of state following the steps that fills one layer and then another. We found that such layer has incrementing steps in going different direction when the layer increments, and a Turing Machine cannot keep track of the layers or the steps. So we tried a different approach, imagining that there’s a little robot that always wants to go right, down, left, then up to form a 2*2 square, but is “blocked” by any space that is already marked, and has to go to an alternate direction. Based on this logic, we built a Turing Machine as such: 
 	Then we build a java program that simulates this graph. We used the BufferedImage class to develop canvas of custom size, and to read and write different colors on the image. Since this function can be easily accessed in main class, but hard to pass in if we want something to happen at each state, we built functions that reads and write depending on some integer input, and then different state classes that decides on what to write, which direction to move, and which state to go to next. We choose the background to be black and the square to be black, and successfully built java programs that acts exactly as a Turing Machine would, and produce squares by adding layers to a single square.
	Then we decided to try to build tree like patterns or snowflake patterns with the same basic structures. We found it to be quite hard, as the TM has to repeat and goes back to a original start point, and also there should be some angles that are cannot be performed by simply going diagonal. While we attempted to do it, we thought that it would have been way easier if we can make the Turing Machines produce Turing Machines recursively, but were not sure if that still falls into our definition, so we did some research online, and it is said that such Machines would be more like Cellular Automatas. We then thought about just repeating patterns for each direction, but there’s no go straight function in Turing Machine, which means we probably need to build the same sets of states for six directions of it was a snowflake, and the pattern will be rather boring.
	At that point we decided to go back to what a Mobile Automata actually does: it reads its color and the color of its neighbors, then decides what color itself turns into. So I first thought about just a simple rule: any color that has a neighboring blue turns into blue. Then I figured that that would be boring, just more blues in the image and nothing more. Then it occurred to me that the reaction of a color turning blue when it has a neighboring blue is similar to a disease being transmitted. So I thought, there should be some antidote. We can make red the strong antidode, able to counteract blue at relatively longer distance, and yellow the weak antidote, able to counteract closer to our cell in danger. As a result, we built states that check the adjacent cells’ color and the go back to the target cell, then move forward. Trillian and I branched off to try to develop two different situations, I tried to make one cell affected by all adjacents, whereas Trillian tried that the cell is affected by what’s at the right and down direction. We also thought it interesting that if the current cell is blue and there’s neighboring blue cells, they can power up and turn all surrounds to blue and make red white, so we tried implementing that function in Trillian’s version. We also guessed that if we use the old output image to be the new input image, we can produce images that is more significantly affected by blue. Unfortunately, due to some bugs we could not figure out, my version mysteriously haults after only processing a small fraction of the whole image. But we think that it is totally doable. We think that this project can also be modified in many different ways, such as change the portion of different colors in the initial input, or change how blue and red are positioned relative to each other, or maybe let the first round be randomly generating blue dots, the second round randomly change the blue dots to red and yellow, and if blue tries to affect the white cell and fails, the white cell can gain immunity and turn into red or yellow, and so on. The mobile automata has potential can simulate infections of different properties.
	We found that mobile automata can mainly be implementing ways of image processing. A simple one state mobile TM can probably always reads the color and dims it, or adjust one of the RGB values to create filter-like effects. The major difference between a regular TM and a mobile TM is that mobile TM moves in a 2-D dimension. Also the 2-D space is finite, and we often come across the problem of changing from one line to the other, but cannot depend on delta’s to determine the boundaries if we do not manually build boundaries. In fact, our line-changing utilities are not done by TMs, as we tried and failed numerous times to use TM and boundaries to change lines. In general, our projects illuminated us on how to implement a TM structure with coding and what are the troubles and possible utilization of mobile automata. 
